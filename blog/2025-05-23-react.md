---
slug: react-side-effects
title: React副作用为什么必须在渲染之外执行
authors: [fangzhijie]
tags: [react]
---

# React 副作用：为什么必须在渲染之外执行

在 React 应用开发中，我们经常需要处理各种副作用（Side Effects）。副作用是指那些不属于 React 渲染过程的操作，比如数据获取、订阅事件、手动修改 DOM 等。

<!-- truncate -->

## 什么是 React 中的渲染过程？

在深入讨论副作用之前，我们需要先理解 React 的渲染过程。React 渲染主要包括以下步骤：

1. 调用组件函数获取 JSX 元素
2. 将 JSX 转换为虚拟 DOM
3. 比较新旧虚拟 DOM（调和/Reconciliation）
4. 更新实际 DOM（提交/Commit）

这个过程应该是**纯粹的**，即给定相同的输入（props 和 state），总是产生相同的输出（React 元素）。

## 什么是副作用？

副作用是指那些会对组件外部环境产生影响的操作，例如：

- 发送网络请求
- 设置计时器或订阅事件
- 修改 DOM
- 本地存储操作
- 日志记录

## 为什么副作用必须在渲染之外执行？

### 1. 保持渲染的纯粹性

React 的渲染过程是声明式的，它描述了 UI 在给定状态下应该是什么样子，而不是如何去改变它。如果在渲染过程中执行副作用，会破坏这种纯粹性，导致渲染结果不稳定。

```jsx
// ❌ 错误做法：在渲染过程中执行副作用
function UserProfile({ userId }) {
  // 这个API调用将在每次渲染时执行
  const userData = fetchUserData(userId); // 直接在组件体内获取数据

  return <div>{userData.name}</div>;
}
```

### 2. 避免无限渲染循环

在渲染过程中执行会导致状态变化的副作用，将导致组件重新渲染，从而形成无限循环。

```jsx
// ❌ 错误做法：在渲染中改变状态
function Counter() {
  const [count, setCount] = useState(0);

  // 这会导致无限循环！
  setCount(count + 1); // 每次渲染都会增加count

  return <div>{count}</div>;
}
```

### 3. 确保一致性和可预测性

如果在渲染过程中执行副作用，那么渲染结果将依赖于这些副作用的执行情况，使得组件行为变得不可预测。

### 4. 提高性能

React 的并发模式和 Fiber 架构允许渲染工作被分割和暂停。如果渲染过程中包含副作用，则可能导致同一副作用执行多次，或者在不应该执行的时候执行。

## 正确处理副作用的方法

React 提供了专门的 API 来处理副作用，主要是 useEffect 钩子（在类组件中是生命周期方法）。

```jsx
// ✅ 正确做法：使用useEffect处理副作用
function UserProfile({ userId }) {
  const [userData, setUserData] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    // 在渲染完成后执行副作用
    const fetchData = async () => {
      setLoading(true);
      try {
        const data = await fetchUserData(userId);
        setUserData(data);
      } catch (error) {
        console.error("Failed to fetch user data:", error);
      } finally {
        setLoading(false);
      }
    };

    fetchData();

    // 清理函数
    return () => {
      // 取消请求或清理资源
    };
  }, [userId]); // 依赖项数组

  if (loading) return <div>Loading...</div>;
  if (!userData) return <div>Error loading data</div>;

  return <div>{userData.name}</div>;
}
```

## useEffect 的依赖项和清理

正确使用 useEffect 需要理解两个关键概念：

### 依赖项数组

依赖项数组告诉 React 什么时候需要重新执行效果：

- `[]` - 仅在组件挂载时执行一次
- `[value1, value2]` - 当 value1 或 value2 改变时执行
- 不提供 - 每次渲染后执行

```jsx
// 仅在组件挂载时执行一次
useEffect(() => {
  document.title = "App Loaded";
}, []);

// 当userId变化时执行
useEffect(() => {
  fetchUserData(userId);
}, [userId]);

// 每次渲染后执行
useEffect(() => {
  console.log("Render completed");
});
```

### 清理函数

useEffect 可以返回一个清理函数，在组件卸载或者效果重新执行前调用，用于清理资源。

```jsx
useEffect(() => {
  const subscription = dataSource.subscribe();

  // 返回清理函数
  return () => {
    subscription.unsubscribe();
  };
}, [dataSource]);
```

## React 18 中的新变化

React 18 引入了并发渲染，这进一步强调了将副作用与渲染分离的重要性。在并发模式下，React 可能会：

- 启动一个渲染然后暂停它
- 丢弃一个正在进行的渲染
- 多次渲染同一个组件

这意味着组件函数可能会被调用多次，但只有一次渲染会被"提交"到 DOM。如果在渲染过程中包含副作用，则这些副作用也可能被多次执行，导致不可预见的问题。

## useEffect vs useLayoutEffect

虽然两者都用于处理副作用，但它们的执行时机不同：

- `useEffect`: 在浏览器绘制之后异步执行，不会阻塞渲染
- `useLayoutEffect`: 在 DOM 更新之后但在浏览器绘制之前同步执行，可能会阻塞渲染

```jsx
function Component() {
  const [value, setValue] = useState(0);

  // 在浏览器绘制后执行
  useEffect(() => {
    console.log("useEffect执行");
  });

  // 在DOM更新后但浏览器绘制前执行
  useLayoutEffect(() => {
    console.log("useLayoutEffect执行");
  });

  return <div>{value}</div>;
}
```

在大多数情况下应该使用`useEffect`，只有在需要在用户看到更新前进行 DOM 测量或修改时才使用`useLayoutEffect`。

> react 官方说 useLayoutEffect 可能会影响性能。尽可能使用 useEffect。
